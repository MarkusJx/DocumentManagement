import React from "react";
import {ChipTextAreaWithAutoComplete} from "./ChipTextArea";
import {Button, Checkbox, OutlinedButton, OutlinedTextField} from "./MDCWrapper";
import {database, PropertyMap} from "../databaseWrapper";
import {PropertySetter} from "./PropertyField";
import {DateRangeTextField} from "./DateTextField";
import constants from "../util/constants";
import {getLogger} from "log4js";

const logger = getLogger();

/**
 * The search box properties
 */
export interface SearchBoxProps {
    // The function to be called when the search is started
    searchStart: () => void;
}

/**
 * A search box
 */
export class SearchBox extends React.Component<SearchBoxProps> {
    /**
     * The filename selector text area
     * @private
     */
    private filenameTextArea: OutlinedTextField;

    /**
     * The file name exact match checkbox
     * @private
     */
    private exact_match_checkbox: Checkbox;

    /**
     * The property selector
     * @private
     */
    private propertySetter: PropertySetter;

    /**
     * The tag selector chip text area
     * @private
     */
    private chipTextArea: ChipTextAreaWithAutoComplete;

    /**
     * The element containing the main content
     * @private
     */
    private mainContentElement: HTMLDivElement;

    /**
     * The html container element
     * @private
     */
    private container: HTMLDivElement;

    /**
     * Whether the main content is shown
     * @private
     */
    private mainContentShown: boolean;

    /**
     * The date range selector text field
     * @private
     */
    private dateRangeTextField: DateRangeTextField;

    /**
     * The search start button
     * @private
     */
    private startButton: Button;

    /**
     * The search start callback function
     * @private
     */
    private readonly searchStart: () => void;

    /**
     * Create a search box
     *
     * @param props the properties
     */
    public constructor(props: SearchBoxProps) {
        super(props);

        this.searchStart = props.searchStart.bind(this);

        this.filenameTextArea = null;
        this.exact_match_checkbox = null;
        this.propertySetter = null;
        this.chipTextArea = null;
        this.mainContentElement = null;
        this.mainContentShown = false;
        this.dateRangeTextField = null;
        this.startButton = null;
        this.container = null;

        this.showHideMainContent = this.showHideMainContent.bind(this);
    }

    /**
     * Set whether the start search button should be enabled
     *
     * @param enabled whether the button should be enabled
     */
    public set startButtonEnabled(enabled: boolean) {
        this.startButton.enabled = enabled;
    }

    /**
     * Get the document filter generated by this search box from the user's inputs
     *
     * @return the generated document filter
     */
    public async getFilter(): Promise<database.DocumentFilter> {
        const filters: database.filters.DocumentFilterBase[] = [];
        if (this.filenameTextArea.value.length > 0) {
            const filename: string = this.filenameTextArea.value;
            const exactMatch: boolean = this.exact_match_checkbox.checked;
            filters.push(await database.filters.FilenameFilter.create(filename, exactMatch));
        }

        if (this.propertySetter.propertyValues.length > 0) {
            const properties: string[] = this.propertySetter.propertyValues
                .flatMap(v => [v.propertyName, v.propertyValue]);

            const map: PropertyMap = PropertyMap.of(...properties);
            filters.push(await database.filters.PropertyFilter.create(map));
        }

        if (this.chipTextArea.chipValues.length > 0) {
            const tags: string[] = this.chipTextArea.chipValues;
            filters.push(await database.filters.TagFilter.create(...tags));
        }

        if (this.dateRangeTextField.value != null) {
            const values: Date[] = this.dateRangeTextField.value;
            filters.push(await database.filters.DateFilter.getByDates(values[0], values[1]));
        }

        return await database.DocumentFilter.create(...filters);
    }

    /**
     * Check if a tag exists
     *
     * @param value the tag to check
     * @return true if the tag exists
     * @private
     */
    private static tagExists(value: string): boolean {
        try {
            return constants.databaseManager.tagExists(value);
        } catch (e) {
            logger.error("An error occurred while checking if a tag exists:", e);
            return false;
        }
    }

    public componentDidMount(): void {
        constants.searchBox = this;
    }

    public componentWillUnmount(): void {
        constants.searchBox = null;
    }

    /**
     * Show or hide the main content
     */
    public showHideMainContent(): void {
        this.mainContentShown = !this.mainContentShown;
        if (this.mainContentShown) {
            this.mainContentElement.style.height = "unset";
            this.mainContentElement.style.marginTop = "20px";
            this.mainContentElement.style.display = "grid";
            this.container.style.padding = '0 20px 20px 20px';
        } else {
            this.mainContentElement.style.height = "0";
            this.mainContentElement.style.marginTop = "0";
            this.mainContentElement.style.display = "none";
            this.container.style.padding = '0';
            this.clear();
        }
    }

    /**
     * Clear all fields
     * @private
     */
    private clear(): void {
        this.filenameTextArea.clear();
        this.exact_match_checkbox.checked = false;
        this.propertySetter.clear();
        this.chipTextArea.clear();
        this.dateRangeTextField.value = null;
    }

    /**
     * Get the tag auto complete options
     *
     * @param value the current value
     * @return the tag auto complete options
     * @private
     */
    private static getTagOptions(value: string): string[] {
        try {
            return constants.databaseManager.getTagsLike(value).map(t => t.name);
        } catch (e) {
            logger.error("An error occurred while getting all tags like a value:", e);
            return [];
        }
    }

    public render(): React.ReactNode {
        const search_button_style: React.CSSProperties = {
            margin: "20px auto 0 auto"
        };

        const date_range_style: React.CSSProperties = {
            margin: "auto 0"
        };

        return (
            <div ref={e => this.container = e} className="search-box__container">
                <div ref={e => this.mainContentElement = e} className="search-box__main-content">
                    <OutlinedTextField title={"File name"} ref={e => this.filenameTextArea = e}
                                       labelId={"search-file-name"}/>
                    <div className="search-box__exact-match-container">
                        <div className="search-box__exact-match-text">
                            Exact match
                        </div>
                        <Checkbox ref={e => this.exact_match_checkbox = e}/>
                    </div>
                    <PropertySetter ref={e => this.propertySetter = e}/>
                    <ChipTextAreaWithAutoComplete getAutoCompleteOptions={SearchBox.getTagOptions} title={"Select tags"}
                                                  chipValueExists={SearchBox.tagExists}
                                                  chipTooltipText={"This tag does not exist. No documents will be found."}
                                                  ref={e => this.chipTextArea = e}/>
                    <div className="search-box__date-range-container">
                        <div className="search-box__date-range-text">
                            Created between
                        </div>
                        <DateRangeTextField style={date_range_style} ref={e => this.dateRangeTextField = e}/>
                    </div>
                    <OutlinedButton text={"Search"} onClick={this.searchStart} style={search_button_style}
                                    ref={e => this.startButton = e}/>
                </div>
            </div>
        );
    }
}